<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nick Chandler</title>
    <link>https://nickchandler.dev/</link>
    <description>Recent content on Nick Chandler</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 Oct 2025 00:36:52 -0400</lastBuildDate>
    <atom:link href="https://nickchandler.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lab Report: Adding Stride Scheduling to xv6</title>
      <link>https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/</link>
      <pubDate>Fri, 03 Oct 2025 21:56:18 -0400</pubDate>
      <guid>https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/</guid>
      <description>&lt;p&gt;The xv6 kernel uses a basic round robin scheduler. To understand scheduling more deeply, I replaced it with a stride scheduler. This post compares round robin and stride scheduling, explains how I added it to xv6, and what I learned along the way.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tldr--key-takeaways&#34;&gt;&#xA;  TL;DR / Key Takeaways&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#tldr--key-takeaways&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;xv6 uses a simple round robin scheduler that treats all runnable processes equally.&lt;/li&gt;&#xA;&lt;li&gt;I replaced it with a stride scheduler to explore proportional-share scheduling.&lt;/li&gt;&#xA;&lt;li&gt;Stride scheduling assigns each process a &amp;ldquo;stride&amp;rdquo; value that determines how often it runs; smaller strides mean higher priority.&lt;/li&gt;&#xA;&lt;li&gt;In a few lines of code, I was able to achieve stride scheduling effectiveness on par with the theoretical expectations.&lt;/li&gt;&#xA;&lt;li&gt;Along the way, I uncovered an interesting startup lockup in &lt;code&gt;init&lt;/code&gt; worth looking into further.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;whats-a-scheduler-again&#34;&gt;&#xA;  What&amp;rsquo;s a Scheduler, Again?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#whats-a-scheduler-again&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;One of the most important responsibilities of an operating system is to select which processes (think: running programs) to run and when. If there were, say, one process running and one CPU on the system, then there&amp;rsquo;s no problem - just let that process run. But, on real systems, there are many processes running at a time and relatively few processors on which to run. To provide the illusion of letting every process run, the OS allows these processes to run for very short bursts of time, then allowing another one to run for a short time, and so on. Choosing which process to run is the role of the OS &lt;strong&gt;scheduler&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 2: Operating System Organization</title>
      <link>https://nickchandler.dev/articles/2025/04/05/xv6-chapter-2-operating-system-organization/</link>
      <pubDate>Sat, 05 Apr 2025 23:06:37 -0400</pubDate>
      <guid>https://nickchandler.dev/articles/2025/04/05/xv6-chapter-2-operating-system-organization/</guid>
      <description>&lt;p&gt;After a bit of an unexpected break, I have been able to get back to my operating systems study. So, let&amp;rsquo;s take a look at some of the key ideas in chapter 2 of the xv6 book!&lt;/p&gt;&#xA;&lt;h2 id=&#34;operating-system-organization&#34;&gt;&#xA;  Operating System Organization&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#operating-system-organization&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;In the introduction to the chapter, the authors claim:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[A]n operating system must fulfill three requirements: multiplexing, isolation, and interaction.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Multiplexing&lt;/strong&gt; refers to multiple programs being able to run on the computer, ideally without any one program hogging time or resources. &lt;strong&gt;Isolation&lt;/strong&gt; means that the operating system must protect programs from one another. And, &lt;strong&gt;interaction&lt;/strong&gt; means that the OS must allow programs to communicate with each other in a safe manner.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 1: Operating System Interfaces</title>
      <link>https://nickchandler.dev/articles/2025/01/12/xv6-chapter-1-operating-system-interfaces/</link>
      <pubDate>Sun, 12 Jan 2025 16:30:45 -0500</pubDate>
      <guid>https://nickchandler.dev/articles/2025/01/12/xv6-chapter-1-operating-system-interfaces/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve recently started an effort to learn more about operating systems, particularly Unix-like systems. Modern operating systems offer a lot of incredible capabilities for application programmers, and they can even provide unique ways of delivering applications. For example, containers are largely possible because of Linux capabilities such as namespaces and cgroups. However, I would like to spend some time digging into the foundations of operating systems so that I have a better framework with which to explore some of these unique, modern capabilities.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Faster Software Development with the Mikado Method</title>
      <link>https://nickchandler.dev/articles/2024/09/21/faster-software-development-with-the-mikado-method/</link>
      <pubDate>Sat, 21 Sep 2024 00:37:00 -0400</pubDate>
      <guid>https://nickchandler.dev/articles/2024/09/21/faster-software-development-with-the-mikado-method/</guid>
      <description>&lt;p&gt;As a software engineer, have you ever faced a complex project where every task seems to depend on another? My team at HashiCorp ran into just that — and found a method that helped us tackle those interdependencies in a way that lets us make smooth progress. Here’s how the &lt;strong&gt;Mikado Method&lt;/strong&gt; improved our workflow.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-challenge&#34;&gt;&#xA;  The Challenge&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#the-challenge&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;About a year ago, my team at HashiCorp tried something new. Our small team was beginning development on a new capability that would require changes to several libraries and a web service, with lots of interdependencies between them. To complicate matters, other teams were waiting on parts of our work to start theirs. We wanted a way that we could all make progress in parallel without the risk of constantly getting blocked by unfinished dependencies.&lt;/p&gt;</description>
    </item>
    <item>
      <title>wishr Repo Setup</title>
      <link>https://nickchandler.dev/articles/2023/11/29/wishr-repo-setup/</link>
      <pubDate>Wed, 29 Nov 2023 09:09:15 -0500</pubDate>
      <guid>https://nickchandler.dev/articles/2023/11/29/wishr-repo-setup/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://nickchandler.dev/articles/2023/11/25/wishr-a-small-shell-written-in-rust/&#34; &gt;previous post&lt;/a&gt;, I described why I&amp;rsquo;m writing a small Unix shell, which I&amp;rsquo;m calling &lt;a href=&#34;https://github.com/nwchandler/wishr&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wishr&lt;/a&gt;, along with a bit of an overview of how I plan to approach the project. I&amp;rsquo;m excited to get started on the shell, itself, but it&amp;rsquo;s important to get a new repo set up for success. So, in this post, I&amp;rsquo;ll go through the initial repository setup I&amp;rsquo;ve gone with.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;d like to look at the specific git commit, &lt;a href=&#34;https://github.com/nwchandler/wishr/commit/2a01c0b8a35c5281f8f9d8e9eb8d6b4051b24cc9&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here it is!&lt;/a&gt; In future changes, I plan to open up PRs and then share links to them instead of pushing changes directly to the &lt;code&gt;main&lt;/code&gt; branch, but as the first substantive commit, I decided to be a little more cavalier on this one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>wishr - A Small Shell Written in Rust</title>
      <link>https://nickchandler.dev/articles/2023/11/25/wishr-a-small-shell-written-in-rust/</link>
      <pubDate>Sat, 25 Nov 2023 22:01:00 -0500</pubDate>
      <guid>https://nickchandler.dev/articles/2023/11/25/wishr-a-small-shell-written-in-rust/</guid>
      <description>&lt;p&gt;This is the first post in a series where I plan to document my experience writing a small Unix shell in &lt;a href=&#34;https://www.rust-lang.org/&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rust&lt;/a&gt; called &lt;strong&gt;wishr&lt;/strong&gt;. In this post, I&amp;rsquo;ll describe why I&amp;rsquo;m starting this project and how I plan to proceed through it.&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-write-a-shell&#34;&gt;&#xA;  Why write a shell?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#why-write-a-shell&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;First off, to be clear, I have no intention to make a production quality shell: &lt;a href=&#34;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bash&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Z_shell&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Z Shell&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Fish_%28Unix_shell%29&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fish&lt;/a&gt;, and the like, can all breathe a sigh of relief here! &amp;#x1f604; This is a learning experience for me, and I want to document the process so that maybe it&amp;rsquo;ll be a learning experience for others too!&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>https://nickchandler.dev/about/</link>
      <pubDate>Wed, 22 Nov 2023 17:10:36 -0500</pubDate>
      <guid>https://nickchandler.dev/about/</guid>
      <description>&lt;p&gt;Hello! &amp;#x1f44b;&lt;/p&gt;&#xA;&lt;p&gt;My name is Nick, and I&amp;rsquo;m a software engineer in Indiana (in the United States). I focus on backend, behind-the-scenes, software; if I am making a UI, it is probably a CLI. &amp;#x1f604;&lt;/p&gt;&#xA;&lt;p&gt;I enjoy learning about computer systems and software, and on this site, I hope to post occasionally about interesting things I learn as well as personal projects I work on.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
