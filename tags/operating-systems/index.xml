<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Operating Systems on Nick Chandler</title>
    <link>https://nickchandler.dev/tags/operating-systems/</link>
    <description>Recent content in Operating Systems on Nick Chandler</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 Oct 2025 23:53:31 -0400</lastBuildDate>
    <atom:link href="https://nickchandler.dev/tags/operating-systems/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lab Report: Adding Stride Scheduling to xv6</title>
      <link>https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/</link>
      <pubDate>Fri, 03 Oct 2025 21:56:18 -0400</pubDate>
      <guid>https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/</guid>
      <description>&lt;p&gt;The xv6 kernel uses a basic round robin scheduler. To understand scheduling more deeply, I replaced it with a stride scheduler. This post compares round robin and stride scheduling, explains how I added it to xv6, and what I learned along the way.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tldr--key-takeaways&#34;&gt;&#xA;  TL;DR / Key Takeaways&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#tldr--key-takeaways&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;xv6 uses a simple round robin scheduler that treats all runnable processes equally.&lt;/li&gt;&#xA;&lt;li&gt;I replaced it with a stride scheduler to explore proportional-share scheduling.&lt;/li&gt;&#xA;&lt;li&gt;Stride scheduling assigns each process a &amp;ldquo;stride&amp;rdquo; value that determines how often it runs; smaller strides mean higher priority.&lt;/li&gt;&#xA;&lt;li&gt;In a few lines of code, I was able to achieve stride scheduling effectiveness on par with the theoretical expectations.&lt;/li&gt;&#xA;&lt;li&gt;Along the way, I uncovered an interesting startup lockup in &lt;code&gt;init&lt;/code&gt; worth looking into further.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;whats-a-scheduler-again&#34;&gt;&#xA;  What&amp;rsquo;s a Scheduler, Again?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#whats-a-scheduler-again&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;One of the most important responsibilities of an operating system is to select which processes (think: running programs) to run and when. If there were, say, one process running and one CPU on the system, then there&amp;rsquo;s no problem - just let that process run. But, on real systems, there are many processes running at a time and relatively few processors on which to run. To provide the illusion of letting every process run, the OS allows these processes to run for very short bursts of time, then allowing another one to run for a short time, and so on. Choosing which process to run is the role of the OS &lt;strong&gt;scheduler&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 2: Operating System Organization</title>
      <link>https://nickchandler.dev/articles/2025/04/05/xv6-chapter-2-operating-system-organization/</link>
      <pubDate>Sat, 05 Apr 2025 23:06:37 -0400</pubDate>
      <guid>https://nickchandler.dev/articles/2025/04/05/xv6-chapter-2-operating-system-organization/</guid>
      <description>&lt;p&gt;After a bit of an unexpected break, I have been able to get back to my operating systems study. So, let&amp;rsquo;s take a look at some of the key ideas in chapter 2 of the xv6 book!&lt;/p&gt;&#xA;&lt;h2 id=&#34;operating-system-organization&#34;&gt;&#xA;  Operating System Organization&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#operating-system-organization&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;In the introduction to the chapter, the authors claim:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[A]n operating system must fulfill three requirements: multiplexing, isolation, and interaction.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Multiplexing&lt;/strong&gt; refers to multiple programs being able to run on the computer, ideally without any one program hogging time or resources. &lt;strong&gt;Isolation&lt;/strong&gt; means that the operating system must protect programs from one another. And, &lt;strong&gt;interaction&lt;/strong&gt; means that the OS must allow programs to communicate with each other in a safe manner.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 1: Operating System Interfaces</title>
      <link>https://nickchandler.dev/articles/2025/01/12/xv6-chapter-1-operating-system-interfaces/</link>
      <pubDate>Sun, 12 Jan 2025 16:30:45 -0500</pubDate>
      <guid>https://nickchandler.dev/articles/2025/01/12/xv6-chapter-1-operating-system-interfaces/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve recently started an effort to learn more about operating systems, particularly Unix-like systems. Modern operating systems offer a lot of incredible capabilities for application programmers, and they can even provide unique ways of delivering applications. For example, containers are largely possible because of Linux capabilities such as namespaces and cgroups. However, I would like to spend some time digging into the foundations of operating systems so that I have a better framework with which to explore some of these unique, modern capabilities.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
