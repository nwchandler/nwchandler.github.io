<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Lab Report: Adding Stride Scheduling to xv6 · Nick Chandler
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Nick Chandler">
<meta name="description" content="Replacing xv6&#39;s round robin scheduler with a stride scheduler to explore proportional-share scheduling and kernel design.">
<meta name="keywords" content="blog,developer">



  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://nickchandler.dev/images/stride-scheduler-theoretical-allocation-by-time.png">
  <meta name="twitter:title" content="Lab Report: Adding Stride Scheduling to xv6">
  <meta name="twitter:description" content="Replacing xv6&#39;s round robin scheduler with a stride scheduler to explore proportional-share scheduling and kernel design.">

<meta property="og:url" content="https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/">
  <meta property="og:site_name" content="Nick Chandler">
  <meta property="og:title" content="Lab Report: Adding Stride Scheduling to xv6">
  <meta property="og:description" content="Replacing xv6&#39;s round robin scheduler with a stride scheduler to explore proportional-share scheduling and kernel design.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-03T21:56:18-04:00">
    <meta property="article:modified_time" content="2025-10-04T00:36:52-04:00">
    <meta property="article:tag" content="Lab">
    <meta property="article:tag" content="Operating Systems">
    <meta property="article:tag" content="Scheduling">
    <meta property="article:tag" content="Xv6">
    <meta property="og:image" content="https://nickchandler.dev/images/stride-scheduler-theoretical-allocation-by-time.png">




<link rel="canonical" href="https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css" integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm&#43;MTzNJdv80k&#43;n0=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://nickchandler.dev/">
      Nick Chandler
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/">
              Lab Report: Adding Stride Scheduling to xv6
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-10-03T21:56:18-04:00">
                October 3, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              14-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/lab/">Lab</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/operating-systems/">Operating Systems</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/scheduling/">Scheduling</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/xv6/">Xv6</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p>The xv6 kernel uses a basic round robin scheduler. To understand scheduling more deeply, I replaced it with a stride scheduler. This post compares round robin and stride scheduling, explains how I added it to xv6, and what I learned along the way.</p>
<h2 id="tldr--key-takeaways">
  TL;DR / Key Takeaways
  <a class="heading-link" href="#tldr--key-takeaways">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>xv6 uses a simple round robin scheduler that treats all runnable processes equally.</li>
<li>I replaced it with a stride scheduler to explore proportional-share scheduling.</li>
<li>Stride scheduling assigns each process a &ldquo;stride&rdquo; value that determines how often it runs; smaller strides mean higher priority.</li>
<li>In a few lines of code, I was able to achieve stride scheduling effectiveness on par with the theoretical expectations.</li>
<li>Along the way, I uncovered an interesting startup lockup in <code>init</code> worth looking into further.</li>
</ul>
<h2 id="whats-a-scheduler-again">
  What&rsquo;s a Scheduler, Again?
  <a class="heading-link" href="#whats-a-scheduler-again">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>One of the most important responsibilities of an operating system is to select which processes (think: running programs) to run and when. If there were, say, one process running and one CPU on the system, then there&rsquo;s no problem - just let that process run. But, on real systems, there are many processes running at a time and relatively few processors on which to run. To provide the illusion of letting every process run, the OS allows these processes to run for very short bursts of time, then allowing another one to run for a short time, and so on. Choosing which process to run is the role of the OS <strong>scheduler</strong>.</p>
<blockquote>
<p>An aside on terminology: Scheduling theory comes not just from the world of computers, but from the world of manufacturing. So, there are some terms that can sometimes be used interchangeably or which can be a bit confusing. For instance, processes are sometimes called &ldquo;jobs.&rdquo; Scheduling policies aren&rsquo;t just called algorithms: they&rsquo;re also called &ldquo;disciplines.&rdquo; And, a set of jobs is a &ldquo;workload.&rdquo; OK, let&rsquo;s get back to the post.</p></blockquote>
<p>How many ways could there be to schedule jobs? Well, a lot, it turns out - different scheduling disciplines work better or worse for different workloads. We&rsquo;re just going to talk about two, though: <strong>round robin</strong> and <strong>stride scheduling</strong>.</p>
<h3 id="round-robin">
  Round Robin
  <a class="heading-link" href="#round-robin">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The xv6 kernel uses a pretty straightforward scheduling discipline by default, known as round robin scheduling. Round robin loops continuously over a list of all the processes on the system, choosing the &ldquo;next&rdquo; one that could run and then running it for a short period of time. It then picks up the loop where it left off, finding whichever process is next in line that is ready to run and then running <em>it</em>. This cycle continues ad infinitum. (Or at least until the machine is turned off.)</p>
<h4 id="round-robin-in-theory">
  Round Robin in Theory
  <a class="heading-link" href="#round-robin-in-theory">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Let&rsquo;s consider how this works, theoretically. The table below shows two hypothetical processes, both ready to run at the same starting time, &ldquo;time 0.&rdquo; Because process 1 is first in the process list, the scheduler chooses it first. After that process runs for a while, the scheduler picks back up and resumes where it left off in the list.</p>
<table>
  <thead>
      <tr>
          <th>Time</th>
          <th>Process 1</th>
          <th>Process 2</th>
          <th>Choice</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>3</td>
          <td>2</td>
          <td>1</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>4</td>
          <td>2</td>
          <td>2</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>5</td>
          <td>3</td>
          <td>2</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>6</td>
          <td>3</td>
          <td>3</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>7</td>
          <td>4</td>
          <td>3</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>8</td>
          <td>4</td>
          <td>4</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>9</td>
          <td>5</td>
          <td>4</td>
          <td>Process 2</td>
      </tr>
  </tbody>
</table>
<p>The corresponding diagram, below, visualizes the number of times each process is scheduled, according to the table above. Process 1 goes, then process 2, repeating over and over. The &ldquo;diamond&rdquo; pattern would continue repeating as long as both processes still had work to do and as long as no other processes started.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/rr-schedule-by-time-theoretical.svg" alt="Theoretical Schedule Allocation by Time (Round Robin)"></p>
<p>Not surprisingly, the split is 50-50 between these theoretical processes based on the previous table.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/rr-schedule-allocation-theoretical.svg" alt="Theoretical Schedule Allocation (Round Robin)"></p>
<h4 id="round-robin-in-practice">
  Round Robin in Practice
  <a class="heading-link" href="#round-robin-in-practice">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Now that we know how round robin ought to behave, let&rsquo;s see how xv6 compares. I wrote a test program that spawns two child processes. Each loops for a while, periodically printing to the console a total of 1000 times. This gives a rough approximation of scheduling behavior.</p>
<p>I&rsquo;ll spare you the table, but here&rsquo;s the timeline from one test execution.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/rr-schedule-by-time-observed.svg" alt="Observed Schedule Allocation by Time (Round Robin)"></p>
<p>Not bad! From looking at the numbers, I can tell you this arbitrary test run had short bursts where one process or the other had a couple more cycles than the other, but concurrency is a tricky thing, and I think it&rsquo;s pretty evident that these processes are being treated pretty equally. Process 0 was the first to finish, but when it reached 1000, Process 1 had run 995 times. The split is pretty even here.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/rr-schedule-allocation-observed.svg" alt="Observed Schedule Allocation (Round Robin)"></p>
<p>So, now we have a handle on how round robin should work and have a pretty good feeling that it works as intended in xv6. Let&rsquo;s turn our attention to stride scheduling.</p>
<h3 id="stride-scheduling">
  Stride Scheduling
  <a class="heading-link" href="#stride-scheduling">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>I mentioned earlier that different scheduling disciplines are better or worse for different workload characteristics. Round robin is a very fair algorithm, treating all processes exactly the same. But, not all processes <em>are</em> the same. Some may be more important than others, and you might want to give them more CPU cycles than less important ones. This scenario is one where round robin falls short.</p>
<p>Some other disciplines support proportional share scheduling. In proportional sharing, you get to specify the relative importance of different processes. For example, you could say, &ldquo;I want my web browser to get twice the CPU cycles as my email client.&rdquo; Some such disciplines rely on probability and randomness, giving important jobs a higher chance of getting picked, but choosing at random (this is known as a <strong>lottery scheduler</strong>). On the other hand, stride scheduling is a deterministic, yet fairly easy-to-implement and effective option.</p>
<h4 id="stride-scheduling-theory">
  Stride Scheduling Theory
  <a class="heading-link" href="#stride-scheduling-theory">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Stride scheduling relies on two critical bits of information about processes. The first is the <strong>stride</strong>, and the other is the <strong>pass</strong>.</p>
<p>Every process starts out with some stride value that is greater than zero, as well as a pass set to 0. Each time the job is scheduled, the scheduler increases the pass by the value of the stride. When the scheduler runs, it checks the current pass value on all runnable processes, choosing to schedule the one with the lowest pass value. (In the event of a tie, it just chooses one, either at random or simply the first runnable process among those tied.)</p>
<p>In pseudocode, this looks something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>scheduler: // runs in a continuous loop
</span></span><span style="display:flex;"><span>  best process = none
</span></span><span style="display:flex;"><span>  for each runnable process:
</span></span><span style="display:flex;"><span>    if the current best process is none:
</span></span><span style="display:flex;"><span>      this is now the best process
</span></span><span style="display:flex;"><span>    else, if this process&#39;s pass value &lt; the best process&#39;s pass:
</span></span><span style="display:flex;"><span>      this is now the best process
</span></span><span style="display:flex;"><span>    else, we already have a better option:
</span></span><span style="display:flex;"><span>      move on to the next runnable process
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  if the best process is still none:
</span></span><span style="display:flex;"><span>    wait a short time and then start again at the top
</span></span><span style="display:flex;"><span>  else:
</span></span><span style="display:flex;"><span>    schedule the best process
</span></span><span style="display:flex;"><span>    (process runs for a short time)
</span></span><span style="display:flex;"><span>    increase this process&#39;s pass by its stride value
</span></span><span style="display:flex;"><span>    start over again at the top
</span></span></code></pre></div><p>The net effect of this is that processes with lower stride values get scheduled more frequently than those with higher stride values. As an analogy, consider two people walking together: one with very long legs and the other with very short legs (like me). These people have different strides. Intuitively, you can probably imagine that to cover the same distance, the person with the shorter stride will need to take more steps than the person with the longer stride. If we assume each &ldquo;step&rdquo; is similar to being scheduled on the CPU, then, this is exactly the same thing that happens in stride scheduling.</p>
<p>How does the stride get set? A simple approach is to assign a priority to a process, and then use that as the denominator in some fixed division of a larger number. For example, if our numerator were fixed at 10,000, then a job with a priority of 50 would be <code>10000 / 50 = 200</code>, whereas a higher priority job of 100 would get a stride of <code>10000 / 100 = 100</code>. Therefore, the higher priority job gets the lower stride. If no priority is set, the system should choose a default stride.</p>
<p>Let&rsquo;s consider, graphically, how this looks in theory. The table below shows a similar situation as we used in our round robin discussion, where two jobs are ready at the same time. But, now, process 1 has a higher priority, with a stride of 100, and process 2 has a lower priority, with a stride of 200.</p>
<table>
  <thead>
      <tr>
          <th>Time</th>
          <th>Process 1 (Stride 100)</th>
          <th>Process 2 (Stride 200)</th>
          <th>Choice</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>100</td>
          <td>0</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>100</td>
          <td>200</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>3</td>
          <td>200</td>
          <td>200</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>4</td>
          <td>300</td>
          <td>200</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>5</td>
          <td>300</td>
          <td>400</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>6</td>
          <td>400</td>
          <td>400</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>7</td>
          <td>500</td>
          <td>400</td>
          <td>Process 2</td>
      </tr>
      <tr>
          <td>8</td>
          <td>500</td>
          <td>600</td>
          <td>Process 1</td>
      </tr>
      <tr>
          <td>9</td>
          <td>600</td>
          <td>600</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>Before we look at the schedule allocation, let&rsquo;s take a look at how the pass values change over this timespan.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/stride-schedule-pass-values-theoretical.svg" alt="Stride Schedule Pass Values Theoretical"></p>
<p>In the diagram, every time a process&rsquo;s line goes up, it means it was scheduled. Note that, generally, the process with stride 100 is scheduled twice as often as the one with stride 200. And, this is the goal, right? If the priority of one job is twice as high as another, we might expect that it ought to get scheduled twice as often as the other.</p>
<p>The following diagrams show this in terms of the number of times each gets scheduled in the example above.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/stride-schedule-by-time-theoretical.svg" alt="Theoretical Schedule Allocation by Time (Stride Scheduling)"></p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/stride-schedule-allocation-theoretical.svg" alt="Theoretical Schedule Allocation (Stride Scheduling)"></p>
<p>With the theory in place, let&rsquo;s look at how I went about adding stride scheduling to xv6.</p>
<h4 id="adding-stride-scheduling-to-xv6">
  Adding Stride Scheduling to xv6
  <a class="heading-link" href="#adding-stride-scheduling-to-xv6">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>I approached adding stride scheduling to xv6 in two major steps:</p>
<ol>
<li>Add the necessary &ldquo;infrastructure&rdquo; for stride scheduling, but with all processes having equal strides.</li>
<li>Add the ability to set the priority on different processes, and test this behavior.</li>
</ol>
<h5 id="implementing-basic-stride-scheduling">
  Implementing Basic Stride Scheduling
  <a class="heading-link" href="#implementing-basic-stride-scheduling">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h5>
<p>The basic stride scheduling mechanisms can be found in <a href="https://github.com/nwchandler/xv6-riscv/commit/619501faae2b4b56338b9e73c8687ba4e85979d5"  class="external-link" target="_blank" rel="noopener">this git commit</a>.</p>
<p>I added stride and pass fields to the process data structure, <code>struct proc</code> in <code>kernel/proc.h</code>. I also defined a numerator (10000) and default priority level (50) for stride settings in <code>kernel/param.h</code>. Using these defaults, I updated the process allocator, <code>allocproc</code> in <code>kernel/proc.c</code>, which sets up new processes, to set all new processes up with a pass of 0, along with a stride of 200 (10000 / 50).</p>
<p>Next, it was time to create the actual scheduler. Rather than changing the scheduler, simply known as <code>scheduler</code>, I created an alternative, which I called <code>stride</code>. The final step in the <code>main</code> function of the kernel is to start the scheduler, so the stride scheduler can be selected by just updating this call in <code>main</code>.</p>
<p>As for the mechanisms of the stride scheduler, it loops through all processes (which xv6 keeps in a fixed-size array), following the pseudocode shown above quite closely. In the commit linked above, the relevant bits can be found in <code>kernel/proc.c</code> from lines <a href="https://github.com/nwchandler/xv6-riscv/commit/619501faae2b4b56338b9e73c8687ba4e85979d5#diff-f06ba4e6ae5b13cb787bad05af2c231bcf826410f25bfd78b18774115f0d20a8R504-R543"  class="external-link" target="_blank" rel="noopener">504-543</a>.</p>
<h5 id="setting-process-priority">
  Setting Process Priority
  <a class="heading-link" href="#setting-process-priority">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h5>
<p>The next step in the implementation involved adding a system call to allow setting the priority on a process, along with adding a user-space test program. These changes are available in <a href="https://github.com/nwchandler/xv6-riscv/commit/0312496a63bc5e4ea7683210a0cb0c699c0dfae1"  class="external-link" target="_blank" rel="noopener">this git commit</a>.</p>
<p>Adding system calls to xv6 is <em>relatively</em> straightforward, although there&rsquo;s enough plumbing involved that I&rsquo;m going to gloss over that for now; maybe I&rsquo;ll write about adding system calls at a later time. The important thing is that the system call <code>setpriority</code> winds up making its way to the new function, <code>setpriority(pid, priority)</code> in the file <code>kernel/proc.c</code>. The function is pretty simple, first doing some basic bounds checking (priority must be between 1 and 100) and then finding the target process and updating its stride. Failure in input validation or finding the process results in an error being returned.</p>
<p>And, this is really about it for setting priorities. Next up, it was time to see how it performed.</p>
<h4 id="stride-scheduling-in-practice">
  Stride Scheduling in Practice
  <a class="heading-link" href="#stride-scheduling-in-practice">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Using the same test program that I used to generate the observed reports for round robin, above, I experimented with different numbers of child processes and different priority levels. Each process runs a tight CPU loop with periodic <code>printf</code>s, so the scheduling behavior primarily reflects CPU allocation rather than I/O blocking.</p>
<p>In the diagram below - similar to the theoretical example earlier - I have one process with stride 100 and one with stride 200. If it works like the theoretical example, we&rsquo;d expect the higher priority job to be scheduled about twice as much as the lower priority one, and therefore, it should progress roughly twice as fast. Let&rsquo;s see how it did.</p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/stride-schedule-by-time-observed.svg" alt="Observed Schedule Allocation by Time (Stride Scheduling)"></p>
<p><img src="/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/stride-schedule-allocation-observed.svg" alt="Observed Schedule Allocation (Stride Scheduling)"></p>
<p><em><strong>VERY COOL!</strong></em> The allocation split was nearly exact (66.8% to 33.2% compared to the theoretical 66.7% to 33.3%). And, in the timeline, notice that when the lower priority process, process 0, gets to some of the &ldquo;round numbers&rdquo; on the vertical axis, it&rsquo;s clear that the higher priority process is twice as high. (For example, 50 to 100, 100 to 200, 400 to 800, etc.) I did cut the chart short after the high priority job finished; once it completed, there was no more contention, so process 0 had as much CPU as it needed, and it finished quickly thereafter.</p>
<h2 id="future-considerations">
  Future Considerations
  <a class="heading-link" href="#future-considerations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Hacking on the xv6 scheduler was fun and helped me solidify my understanding of round robin and stride scheduling disciplines. I was proper chuffed to find that the behavior of my stride scheduler so closely matched the expected behavior of a theoretical scheduler in, frankly, not that many lines of code.</p>
<p>There <em>were</em> some things I left as loose ends during this process that I want to come back to later, though.</p>
<h3 id="pass-value-resets">
  Pass Value Resets
  <a class="heading-link" href="#pass-value-resets">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>First, there is an important thing missing in my implementation that would be important in a real one. If a process were to run for a long time, its pass would grow and grow. As new processes started, even if they were lower priority, their passes could be so drastically lower than such long running processes, that the long running ones would periodically &ldquo;starve&rdquo; until the low priority processes completed or finally caught up.</p>
<p>So, an alternative implementation would address this behavior. One idea is to periodically reset all pass values to 0. This would both keep the behavior more consistent, and it would also eliminate the possibility of integer overflows on pass values for <strong>very</strong> long running processes. (The pass value is a 64-bit unsigned integer, so overflow is exceptionally unlikely, but it would be better to be correct.)</p>
<h3 id="unexplained-init-process-lockup">
  Unexplained Init Process Lockup
  <a class="heading-link" href="#unexplained-init-process-lockup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The second, more interesting challenge, involves some odd behavior I noticed while testing. In order to test the scheduler, I set the number of CPUs in my qemu machine to 1. (Dealing with one processor and multiple processes makes behavior more deterministic and ensures there is contention that forces scheduling behaviors you want to see.)</p>
<p>When I first started up the machine with my stride scheduler, it just hung. The init process started, but it never finished starting up the shell. After some debugging, I found that the init process was going to sleep while trying to open the console (common for system calls), but it was failing to wake up. I found that the context of the process that tried to wake the init process <em>was</em> still the init process. However, there was a guard in the <code>wakeup()</code> function that prevents one process from waking itself. (Keen observers may have noticed that I removed this guard in the second commit, <a href="https://github.com/nwchandler/xv6-riscv/commit/0312496a63bc5e4ea7683210a0cb0c699c0dfae1#diff-f06ba4e6ae5b13cb787bad05af2c231bcf826410f25bfd78b18774115f0d20a8L648-R652"  class="external-link" target="_blank" rel="noopener">here</a>.)</p>
<p>Very strangely, this behavior did not occur when starting with the default scheduler on one CPU. I don&rsquo;t think this is actually attributable to the stride scheduler, but rather due to schedule timing differences. I want to trace this more deeply and determine why my stride scheduler exposed this deadlock, while the round robin scheduler did not. For the time being, though, I skipped the guard check, and all appears to work properly.</p>
<h2 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>If you&rsquo;ve made it this far, thanks for following along with my notes from what was a fun lab experiment. I found this lab to be a great way to turn theoretical knowledge of schedulers into something concrete.</p>
<p>As I explore the future threads mentioned above, I plan to document those as well, especially the init process lockup. I also think at some point, I may try implementing some other scheduler types in xv6, like multi-level feedback queues or lottery schedulers. I&rsquo;ll document those when I do, too.</p>
<p>I hope you&rsquo;ve found this post useful. I&rsquo;ll share notes from future experiments here as I go!</p>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
    <section class="container">
        ©
        
        2023 -
        
        2025
         Nick Chandler 
        ·
        
        Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a
            href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.

        
        [v. f0dd50b]
        

    </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
